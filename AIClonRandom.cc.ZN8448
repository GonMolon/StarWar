#include "Player.hh"
#include <vector>
#include <map>
#include <stack>

using namespace std;

#define PLAYER_NAME ClonRandom

struct PLAYER_NAME : public Player {

	static Player* factory () {
		return new PLAYER_NAME;
	}

	struct Data_pos {
		Pos prev;
		int m;
	};

	typedef pair<Pos, Data_pos> Nodo;

	struct compare {
		bool operator() (const Pos& p1, const Pos& p2) const{
			if(first(p1) != first(p2)) {
				return first(p1) < first(p2);
			} else {
				return second(p1) < second(p2);
			}
		}
	};

	typedef map<Pos, Data_pos, compare> Nodos;

	struct Target {
		Nodo n;
		stack<Pos> route;
		int missiles_nec;
		int rounds_nec;
		bool ok;
		CType type;

		void set_route(Nodos &nodos, const Nodo &n) {
			if(n.first != n.second.prev) {
				route.push(n.first);
				Nodos::iterator i = nodos.find(n.second.prev);
				if(i != nodos.end()) {
					Nodo aux = *i;
					nodos.erase(i);
					set_route(nodos, aux);
				}
			}
		}

		void add_step(const Pos &p) {
			route.push(p);
		}
	};

	class Targets {
	public:
		Targets() {}

		Targets(int size, int offset) {
			this->offset = offset;
			Target t;
			t.ok = false;
			v = vector<Target>(size, t);
		}

		Target& operator[](Starship_Id id) {
			return v[id-offset];
		}

		bool avaliable(Starship_Id id, const Pos &p) {
			for(int i = 0; i < v.size(); ++i) {
				if(id-offset != i && v[i].ok && v[i].n.first == p) {
					return false;
				}
			}
			return true;
		}
		int offset = 0;
	private:
		vector<Target> v;
	};

	Targets targets;

	typedef vector<vector<Cell> > Stage;

	//TODO add const methods
	class Simulation {
	public:
		Stage stage;

		Simulation() {}

		Simulation(const Pos &from, const Pos &to, int n) {
			int i = first(from)-1;
			if(i < 0) {
				i = 0;
			}
			int j = second(to)-4;
			if(j < 0) {
				j = 0;
			}
			ref = {i, j};
			if(first(from) == n-1 || first(from) == 0) {
				n = 2;
			} else {
				n = 3;
			}
			stage = Stage(n, vector<Cell>(second(to-ref)+1));
		}

		void run() {
			for(int i = 0; i < stage.size(); ++i) {
				for(int j = stage[0].size()-1; j >= 0; --j) {
					if(stage[i][j].type == MISSILE) {
						stage[i][j].type = EMPTY;
						bool crash = false;
						for(int k = 1; !crash && k <= 2; ++k) {
							if(j+k < stage[0].size() && stage[i][j+k].type != EMPTY) {
								crash = true;
								stage[i][j+k].type = EMPTY;
							}
						}
						if(!crash && j+2 < stage[0].size()) {
							stage[i][j+2].type = MISSILE;
						}
					}
				}
			}
		}

		bool can_move(const Pos &p, Dir d, Starship_Id begin, Starship_Id end) const {
			if(!check_movement(p, d)) {
				return false;
			}
			for(int j = -2; j < 0; ++j) {
				Dir d = {0, j};
				pair<int, int> ij = get_ij(p-d);
				Cell c = stage[ij.first][ij.second];
				if(c.type == MISSILE || (c.sid != -1 && (c.sid < begin || c.sid > end))) {
					return false;
				}
			}
			return true;
		}

		Dir get_free_dir(const Pos &from, const vector<Dir> &all_dirs, Starship_Id begin, Starship_Id end) const {
			for(int d = 0; d < all_dirs.size(); ++d) {
				cerr << all_dirs[d] << endl;

				if(can_move(from, all_dirs[d], begin, end)) {
					return all_dirs[d];
				}
			}
			return DEFAULT;
		}

		void add_starship(Starship_Id id, const Pos& p) {
			pair<int, int> ij = get_ij(p);
			if(affects(ij)) {
				stage[ij.first][ij.second].type = STARSHIP;
				stage[ij.first][ij.second].sid = id;
			}
		}

		void set_cell(const Pos &p, const Cell &c) {
			pair<int, int> ij = get_ij(p);
			if(affects(ij)) {
				stage[ij.first][ij.second] = c;
			}
		}

		Cell get_cell(const Pos &p) {
			pair<int, int> ij = get_ij(p);
			if(affects(ij)) {
				return stage[ij.first][ij.second];
			}
			Cell c;
			c.type = EMPTY;
			return c;
		}

		Pos ref;

	private:
		bool affects(const pair<int, int> &p) const {
			return p.first >= 0 && p.first < stage.size() && p.second >= 0 && p.second < stage[0].size();
		}

		pair<int, int> get_ij(const Pos &p) const {
			pair<int, int> ij;
			ij.first = first(p-ref);
			ij.second = second(p-ref);
			return ij;
		}

		bool cell_ok(const Pos &p) const {
			pair<int, int> ij = get_ij(p);
			Cell c = stage[ij.first][ij.second];
			return c.type != ASTEROID && c.type != MISSILE;
		}

		bool check_movement(const Pos &p, const Dir &d) const {
			if(!cell_ok(p+d)) {
				return false;
			} else if(d == FAST) {
				return cell_ok(p+DEFAULT);
			} else if(d == FAST_UP) {
				return check_movement(p, UP) && check_movement(p, FAST);
			} else if(d == FAST_DOWN) {
				return check_movement(p, DOWN) && check_movement(p, FAST);
			} else if(d == UP) {
				return cell_ok(p+SLOW_UP) && cell_ok(p+DEFAULT);
			} else if(d == DOWN) {
				return cell_ok(p+SLOW_DOWN) && cell_ok(p+DEFAULT);
			} else {
				return true;
			}
		}
	};

	void reload_simulation(Simulation &s) {
		Dir d;
		for(int i = 0; i < s.stage.size(); ++i) {
			for(int j = 0; j < s.stage[0].size(); ++j) {
				d = {i, j};
				s.stage[i][j] = cell(s.ref+d);
			}
		}
	}

	vector<Dir> all_dirs;

	bool cell_ok(const Pos &p) {
		return cell(p).type != ASTEROID; //c.type == EMPTY || c.type == POINT_BONUS || c.type == MISSILE_BONUS;
	}

	bool check_movement(const Pos &p, const Dir &d, bool has_missiles) {
		if(d == DEFAULT) {
			return cell_ok(p+d) || has_missiles;
		} else if(!cell_ok(p+d)) {
			return false;
		} else if(d == FAST) {
			return cell_ok(p+DEFAULT);
		} else if(d == FAST_UP) {
			return check_movement(p, UP, has_missiles) && check_movement(p, FAST, has_missiles);
		} else if(d == FAST_DOWN) {
			return check_movement(p, DOWN, has_missiles) && check_movement(p, FAST, has_missiles);
		} else if(d == UP) {
			return cell_ok(p+SLOW_UP) && cell_ok(p+DEFAULT);
		} else if(d == DOWN) {
			return cell_ok(p+SLOW_DOWN) && cell_ok(p+DEFAULT);
		} else {
			return true;
		}
	}

	///
	/// \brief choose_target sirve para escoger un objetivo y un recorrido para
	/// \param s
	/// \return devuelve el objetivo seleccionado
	///

	Target choose_target(const vector<Target> &v, int i) {
		//TODO implementar choose_target
		return v[0];
	}

	#define MAX_LEVEL 15
	#define N_TARGETS 1

	//TODO realizar adaptacion alternativa algoritmo dijkstra: busqueda+camino minimo a la vez
	bool scan_target(const Starship &s, Target &t, CType type) {
		vector<Target> v = vector<Target>(N_TARGETS);
		Nodos visited = Nodos();
		queue<Nodo> q;
		Nodo n;
		n.first = s.pos;
		n.second.m = s.nb_miss;
		n.second.prev = n.first;
		q.push(n);
		visited.insert(n);
		int r = 0;
		int i = 0;
		int current_level = 1;
		int next_level = 0;
		Nodo act;
		while(!q.empty() && i < N_TARGETS) { //&& r <= MAX_LEVEL) {
			act = q.front();
			if(cell(act.first).type == type) {
				if(targets.avaliable(s.sid, act.first)) {
					v[i].n = act;
					v[i].rounds_nec = r;
					v[i].type = type;
					v[i].missiles_nec = s.nb_miss-act.second.m;
					++i;
				}
			}
			for(int j = 0; j < all_dirs.size(); ++j) {
				Pos pos_new = act.first+all_dirs[j];
				if(visited.find(pos_new) == visited.end()
						&& within_window(pos_new, round()+r)
						&& check_movement(act.first, all_dirs[j], false&&act.second.m > 0)) {
					n.first = pos_new;
					n.second.prev = act.first;
					n.second.m = act.second.m - !cell_ok(pos_new);
					visited.insert(n);
					q.push(n);
					++next_level;
				}
			}
			q.pop();
			--current_level;
			if(current_level == 0) {
				current_level = next_level;
				next_level = 0;
				++r;
			}
		}
		if(i != 0) {
			t = choose_target(v, i-1);
			t.set_route(visited, t.n);
			return true;
		} else {
			return false;
		}
	}

	void print_pos(const Pos &p) {
		//TODO quitar esto
		cerr << '(' << first(p) << ',' << second(p) << ')' << endl;
		//cerr << "celda = " << cell(p).type << endl;
	}

	void print_route(const Starship &s) {
		stack<Pos> pila = targets[s.sid].route;
		while(!pila.empty()) {
			print_pos(pila.top());
			pila.pop();
		}
	}

	//TODO estructura de datos para almacenar naves enemigas
	//TODO posible campo rondas espera sin adjudicar target para evitar hacer un bfs cada ronda si en la anterior no habia nada

	Dir get_dir(const Pos& from, const Pos& to) {
		//TODO en teoria no hace falta esta funcion si siempre son correctas las direcciones
		Dir d = to-from;
		for(int i = 0; i < all_dirs.size(); ++i) {
			if(d == all_dirs[i]) {
				return d;
			}
		}
		if(false) {
			return DEFAULT;
		}
		return {-1, -1};
	}

	bool dispara(const Starship &s) {
		Dir d;
		for(int i = 1; i <= 2; ++i) {
			d = {0, i};
			if(player_of(cell(s.pos+d).sid) == me()) {
				if(i == 1) {
					next_positions[s.sid-targets.offset] = s.pos+SLOW;
				} else {
					next_positions[s.sid-targets.offset] = s.pos+DEFAULT;
				}
				return false;
			} else if(cell(s.pos+d).type != EMPTY) {
				shoot(s.sid);
				next_positions[s.sid-targets.offset] = s.pos+DEFAULT;
				return true;
			}
		}
		shoot(s.sid);
		next_positions[s.sid-targets.offset] = s.pos+DEFAULT;
		return true;
	}

	void recalculate_route(const Starship &s, const Simulation &simulation) {
		Dir d = simulation.get_free_dir(s.pos, all_dirs, begin(me()), end(me()));
		move(s.sid, d);
		cerr << "recalcular ruta" << endl;
		targets[s.sid].ok = false;
	}

	bool check_safe(const Starship &s) {
		Simulation simulation = Simulation(s.pos, targets[s.sid].route.top(), number_rows());
		reload_simulation(simulation);
		for(Starship_Id id = begin(me()); id != s.sid; ++id) {
			if(targets[id].ok) {
				simulation.add_starship(id, next_positions[id-targets.offset]);
			}
		}
		simulation.run();
		Dir d = get_dir(s.pos, targets[s.sid].route.top());
		Dir aux = {-1, -1};
		Cell c = simulation.get_cell(s.pos+d);
		if(c.type == ASTEROID) {
			Cell aux_c;
			aux_c.type = EMPTY;
			simulation.set_cell(s.pos+d, aux_c);
		}
		bool reachable = d != aux;
		if(reachable && simulation.can_move(s.pos, d, begin(me()), end(me()))) {
			return true;
		} else {
			if(c.type == ASTEROID) {
				simulation.set_cell(s.pos+d, c);
			}
			recalculate_route(s, simulation);
			return false;
		}
	}

	void refresh_target(const Starship &s) {
		if(!targets[s.sid].ok || cell(targets[s.sid].n.first).type != targets[s.sid].type) {
			targets[s.sid].ok = scan_target(s, targets[s.sid], POINT_BONUS);
		}
	}

	///
	/// \brief play    asigna un objetivo a cada nave al principio y mueve a cada nave seg?n su objetivo. También actualiza
	/// la posición de las naves enemigas en función de sus antiguas posiciones para no tener que hacer una b?squeda en cada turno.
	///

	vector<Pos> next_positions;

	virtual void play () {
		if(round() == 0) {
			all_dirs = {FAST, FAST_UP, FAST_DOWN, DEFAULT, UP, DOWN, SLOW, SLOW_UP, SLOW_DOWN};
			targets = Targets(number_starships_per_player(), begin(me()));
			next_positions = vector<Pos>(number_starships_per_player());
		}
		for(Starship_Id id = begin(me()); id != end(me()); ++id) {
			Starship s = starship(id);
			if(s.alive) {
				refresh_target(s);
				if(check_safe(s)) {
					//TODO check cell_ok
					if(!cell_ok(targets[id].route.top())) {
						dispara(s);
					} else {
						move(id, get_dir(s.pos, targets[id].route.top()));
						next_positions[id-targets.offset] = targets[id].route.top();
					}
					targets[id].route.pop();
				}
				if(targets[id].route.empty()) {
					targets[id].ok = false;
				}
			} else {
				targets[id].ok = false;
			}
		}
		//TODO implementar update enemigos
	}
};

RegisterPlayer(PLAYER_NAME);

